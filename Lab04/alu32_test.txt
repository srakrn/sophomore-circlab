op[4]	A[32]		B[32]		sa[5]	C[32]		V

# SLL test (0000)
# We intends to check if the bit shift is properly functioning by checking with values existing only of 0s and 1s, along with the no-shift (shamt = 0) and max shift (shamt = 32). This applies to all shift.
0000	0x0			0x0			0		0x0			0
0000	0x0			0x0			31		0x0			0
0000	0x0			0xffffffff	0		0xffffffff	0
0000	0x0			0xffffffff	31		0x80000000	0
0000	0x0			0x00000001	1		0x00000002	0

# Add (0010)
# We tries to add the integer boundaries to check for errors. The maximum and minimum values (0x7fffffff, 0x80000000) are choosed and paired to make the tests. This also applies to subtract.
0010	0x1			0x7fffffff	0		0x80000000	1
0010	0x80000000	0x7fffffff	0		0xffffffff	0
0010	0x0			0x80000000	0		0x80000000	0
0010	0xffffffff	0x80000000	0		0x7fffffff	1
0010	0x00000000	0x00000000	0		0x00000000	0

# SRL (0100)
0100	0x0			0x0			0		0x0			0
0100	0x0			0x0			31		0x0			0
0100	0x0			0xffffffff	0		0xffffffff	0
0100	0x0			0xffffffff	31		0x1			0
0100	0x0			0x00000001	1		0x0			0

# SRA (0101)
0101	0x0			0x0			0		0x0			0
0101	0x0			0x0			31		0x0			0
0101	0x0			0xffffffff	0		0xffffffff	0
0101	0x0			0xffffffff	31		0xffffffff	0
0101	0x0			0x80000000	1		0xc0000000	0

# Subtract (0110)
0110	0x80000000	0x1			0		0x7fffffff	1
0110	0x80000000	0x7fffffff	0		0x00000001	1
0110	0x0			0x80000000	0		0x80000000	1
0110	0xffffffff	0x80000000	0		0x7fffffff	0
0110	0x00000000	0x00000001	0		0xffffffff	0

# And (1000)
# For simplicity, we try checking `and` with the combination of entirely zero (0x00000000) and entirely one (0xffffffff) combined together (thus representing an ordinary truth table) along with one random test. This applies to all AND/OR/XOR/NOR/Eq/Ne tests.
1000	0x00000000	0x00000000	0		0x00000000	0
1000	0x00000000	0xffffffff	0		0x00000000	0
1000	0xffffffff	0x00000000	0		0x00000000	0
1000	0xffffffff	0xffffffff	0		0xffffffff	0
1000	0xf0f0f0f0	0x0f0f0f0f	0		0x00000000	0

# Or (1010)
1010	0x00000000	0x00000000	0		0x00000000	0
1010	0x00000000	0xffffffff	0		0xffffffff	0
1010	0xffffffff	0x00000000	0		0xffffffff	0
1010	0xffffffff	0xffffffff	0		0xffffffff	0
1010	0xf0f0f0f0	0x0f0f0f0f	0		0xffffffff	0

# Xor (1100)
1100	0x00000000	0x00000000	0		0x00000000	0
1100	0x00000000	0xffffffff	0		0xffffffff	0
1100	0xffffffff	0x00000000	0		0xffffffff	0
1100	0xffffffff	0xffffffff	0		0x00000000	0
1100	0xf0f0f0f0	0x0f0f0f0f	0		0xffffffff	0

# Nor (1110)
1110	0x00000000	0x00000000	0		0xffffffff	0
1110	0x00000000	0xffffffff	0		0x00000000	0
1110	0xffffffff	0x00000000	0		0x00000000	0
1110	0xffffffff	0xffffffff	0		0x00000000	0
1110	0xf0f0f0f0	0x0f0f0f0f	0		0x00000000	0

# Eq (1001)
1001	0x00000000	0x00000000	0		0x00000001	0
1001	0x00000000	0xffffffff	0		0x00000000	0
1001	0xffffffff	0x00000000	0		0x00000000	0
1001	0xffffffff	0xffffffff	0		0x00000001	0
1001	0x0f0f0f0f	0x0f0f0f0f	0		0x00000001	0

# Ne (1011)
1011	0x00000000	0x00000000	0		0x00000001	0
1011	0x00000000	0xffffffff	0		0x00000001	0
1011	0xffffffff	0x00000000	0		0x00000001	0
1011	0xffffffff	0xffffffff	0		0x00000000	0
1011	0x0f0f0f0f	0x0f0f0f0f	0		0x00000000	0

# Lt (1101)
# Like adding, we check the correction at the boundaries by comparing zero to the minimum/maximum values of the signed int. This applies to Gt too.
1101	0x00000000	0x7fffffff	0		0x1			0
1101	0x80000000	0x00000000	0		0x1			0
1101	0x80000000	0x7fffffff	0		0x1			0
1101	0x7fffffff	0x80000000	0		0x0			0
1101	0x00000000	0x00000000	0		0x0			0

# Gt (1111)
1111	0x00000000	0x7fffffff	0		0x0			0
1111	0x80000000	0x00000000	0		0x0			0
1111	0x80000000	0x7fffffff	0		0x0			0
1111	0x7fffffff	0x80000000	0		0x1			0
1111	0x00000000	0x00000000	0		0x0			0
